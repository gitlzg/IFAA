---
title: "Introduction to IFAA"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{IFAA}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(IFAA)
```

IFAA is a novel approach to make inference on the association of covariates with the absolute abundance (AA) of microbiome in an ecosystem. 

To model the association, the following equation is used: 
$$
\log(\mathcal{Y}_i^k)|\mathcal{Y}_i^k>0=\beta^{0k}+X_i^T\beta^k+W_i^T\gamma^k+Z_i^Tb_i+\epsilon_i^k,\hspace{0.2cm}k=1,...,K+1,
$$
where

- $\mathcal{Y}_i^k$ is the AA of taxa $k$ in subject $i$ in the entire ecosystem. 

- $X_i$ is the covariate matrix

- $W_i$ is the confounder matrix

- $Z_i$ is the random effect matrix. 

- $\beta^k$ is the parameter that will be estimated and tested with the IFAA package. 

The challenge in microbiome analysis is that we can not oberve $\mathcal{Y}_i^k$. What is observed is its small proportion: $Y_i^k=C_i\mathcal{Y}^k_i$ where $C_i$ is an unknown number between 0 and 1 that denote the observed proportion. 

The IFAA method can handle this challenge by identifying and employing reference taxa.

## Input and Output

The package "IFAA" could be installed from GitHub using the following code: 

```{r eval=FALSE}
require(devtools)
devtools::install_github("gitlzg/IFAA")
library(IFAA)
```

The `IFAA()` function is the main function accessed by the users. The User Inputs are: 

- `MicrobData`: Microbiome data matrix containing microbiome abundance with each row per sample and each column per taxon/OTU/ASV. It should contain an `"id"` variable to correspond to the `"id"` variable in the covariates data: `CovData`.

- `CovData`: Covariates data matrix containing covariates and confounders with each row per sample and each column per variable. It should also contain an `"id"` variable to correspond to the `"id"` variable in the microbiome data: `MicrobData`.

- `linkIDname`: Variable name of the `"id"` variable in both `MicrobData` and `CovData`. The two data sets will be merged by this `"id"` variable.

- `testCov`: Covariates that are of primary interest for testing and estimating the associations. It corresponds to $X_i$ in the equation. Default is `NULL` which means all covariates are `testCov`.

- `ctrlCov`: Potential confounders that will be adjusted in the model. It corresponds to $W_i$ in the equation. Default is `NULL` which means all covariates except those in `testCov` are adjusted as confounders.

- `testMany`: This takes logical value `TRUE` or `FALSE`. If `TRUE`, the `testCov` will contain all the variables in `CovData` provided `testCov` is set to be `NULL`. The default value is `TRUE` which does not do anything if `testCov` is not `NULL`.

- `ctrlMany`: This takes logical value `TRUE` or `FALSE`. If `TRUE`, all variables except `testCov` are considered as control covariates provided `ctrlCov` is set to be `NULL`. The default value is `TRUE` which does not do anything if `ctrlCov` is not `NULL`.

- `nRef`: The number of randomly picked reference taxa used in phase 1. Default number is `40`. 

- `nPermu`: The number of permutation used in phase 1. Default number is `40`. 

- `refTaxa`: Reference taxa will be used in phase 1. The default is `NULL` since the algorithm will pick those randomly. If a vector of taxa names are provided, the algorithm will use the provided taxa instead of randomly picking random reference taxa.

- `reguMethod`: regularization approach used in phase 1 of the algorithm. Take value `"mcp"` or `"lasso"`, default is `"mcp"`.

- `fwerRate`: The family wise error rate for identifying taxa/OTU/ASV associated with `testCov` in phase 1. Default is `0.25`.

- `paraJobs`: Number of parallel jobs that will be registered to run the algorithm. Default is `8`. If specified as `NULL`, it will automatically detect the cores to decide the number of parallel jobs.

- `sequentialRun`: This takes a logical value `TRUE` or `FALSE`. Sometimes parallel jobs can not be successfully run for unknown reasons (such as hardware issues). For example, socket related errors may pop up or some slave cores return error message instead of numerical results. In those scenarios, setting `sequentialRun = TRUE` may help, but it will take more time to run. Default is `FALSE`.

- `standardize`: This takes a logical value `TRUE` or `FALSE`. If `TRUE`, all design matrix X in phase 1 and phase 2 will be standardized in the analyses. Default is `FALSE`.

- `nRefMaxForEsti`: The maximum number of reference taxa used in phase 2. The default is `1`.

- `bootB`: Number of bootstrap samples for obtaining confidence interval of estimates in phase 2. The default is `500`.

- `bootLassoAlpha`: The significance level in phase 2. Default is `0.05`.

- `refReadsThresh`: The threshold of non-zero sequencing reads for choosing the reference taxon in phase 2. The default is `0.2` which means at least 20% non-zero sequencing reads.

- `SDThresh`: The threshold of standard deviations of sequencing reads for choosing the reference taxon in phase 2. The default is `0.5` which means the standard deviation of sequencing reads should be at least `0.5`.

- `balanceCut`: The threshold of non-zero sequencing reads in each group of a binary variable for choosing the reference taxon in phase 2. The default number is `0.2` which means at least 20% sequencing reads are non-zero in each group.

- `seed`: Random seed for reproducibility. Default is `1`.

The output of `IFAA()` function is a list. The estimation results can extracted as the following: 

- `analysisResults$estByCovList`: A list containing estimating results for all the variables in `testCov`. See details. 

The covariates data including `testCov` and `ctrlCov` can be extracted in the output:

- `covariatesData`: A dataset containing covariates and confounders used in the analyses


## Examples

The example datasets `dataM` and `dataC` are included in the package. They could be accessed by: 
```{r}
data(dataM)
dim(dataM)
dataM[1:5, 1:8]

data(dataC)
dim(dataC)
dataC[1:5, ]
```
Both the microbiome data `dataM` and the covariates data `dataC` contain 20 samples (i.e., 20 rows). 

- `dataM` contains 60 taxa with absolute abundances and these are gut microbiome.  

- `dataC` contains 5 covariates. 

Next we analyze the data to test the association between microbiome and the two variables `"v1"` and `"v2"` while adjusting for the variable `"v3"`.

```{r, eval=T}
results <- IFAA(MicrobData = dataM,
                CovData = dataC,
                linkIDname = "id",
                testCov = c("v1", "v2"),
                ctrlCov = c("v3"),
                nRef = 4,
                nPermu = 4,
                fwerRate = 0.25,
                bootB = 5)
```


In this example, we are only interested in testing the association with `"v1"` and `"v2"` which is why `testCov=c("v1,"v2")`. The variable `"v3"` is adjusted as a potential confounder in the analyses. For the sake of speed in this hypothetical example, we set small numbers for `nRef=4`, `nPermu=4` and `bootB=5`. These are just for illustration purpose here and are too small for a formal analysis to generate valid results. 

The final analysis results are stored in the list `analysisResults$estByCovList`: 
```{r,eval=T}
results$analysisResults$estByCovList
```
The results found the two taxa `"rawCount29"` and `"rawCount42"` associated with `"v2"`. The regression coefficients and their 95% confidence intervals are provided. These coefficients correspond to $\beta^k$ in the model equation. 

The interpretation is that 

- Every unit increase in `"v2"` is associated with approximately 2% increase in the absolute abundance of `"rawCount29"` and approximately 0.4% increase in the absolute abundance of `"rawCount42"` in the entire gut ecosystem. 

- There were no taxa associated with `"v1"` in the analysis. 

All the analyzed covariates including `testCov` and `ctrlCov` are stored in the object: `covariatesData`: 

```{r,eval=T}
results$covariatesData
```
